Grammar:

Rule 0     S' -> statement
Rule 1     statement -> var_assign
Rule 2     statement -> condition
Rule 3     statement -> FOR IDENTIFIER IN expr {
Rule 4     statement -> WHILE ( condition ) {
Rule 5     statement -> ELSE {
Rule 6     statement -> IF ( condition ) {
Rule 7     statement -> IDENTIFIER + +  [precedence=left, level=1]
Rule 8     statement -> ARROWOP GLOBAL IDENTIFIER
Rule 9     statement -> expr ARROWOP IDENTIFIER ( )
Rule 10    statement -> ARROWOP IDENTIFIER
Rule 11    statement -> WRITE condition
Rule 12    statement -> WRITE expr
Rule 13    statement -> expr
Rule 14    statement -> IDENTIFIER ARRAY = expr
Rule 15    statement -> } END
Rule 16    statement -> ASSERT ( condition ) , expr
Rule 17    statement -> EXCEPT {
Rule 18    statement -> ERROR IDENTIFIER END
Rule 19    statement -> THROW IDENTIFIER , expr
Rule 20    statement -> TRY {
Rule 21    statement -> }
Rule 22    statement -> INCLUDE STRING
Rule 23    statement -> RETURN condition
Rule 24    statement -> RETURN expr
Rule 25    statement -> FUNCTION IDENTIFIER ( ) {
Rule 26    expr -> IDENTIFIER ( )
Rule 27    expr -> PARAM expr
Rule 28    expr -> ARGV
Rule 29    expr -> ARGC
Rule 30    expr -> expr ARRAY
Rule 31    expr -> ARRAY
Rule 32    expr -> FLOAT
Rule 33    expr -> GLOBAL IDENTIFIER
Rule 34    expr -> IDENTIFIER
Rule 35    expr -> ( expr )
Rule 36    expr -> - expr  [precedence=right, level=3]
Rule 37    expr -> NUMBER
Rule 38    expr -> STRING
Rule 39    expr -> expr / expr  [precedence=left, level=2]
Rule 40    expr -> expr * expr  [precedence=left, level=2]
Rule 41    expr -> expr ^ expr
Rule 42    expr -> expr % expr
Rule 43    expr -> expr - expr  [precedence=left, level=1]
Rule 44    expr -> expr + expr  [precedence=left, level=1]
Rule 45    expr -> TYPEOF expr
Rule 46    condition -> expr < expr
Rule 47    condition -> expr NOTEQ expr
Rule 48    condition -> expr EQSTHAN expr
Rule 49    condition -> expr EQGTHAN expr
Rule 50    condition -> expr > expr
Rule 51    condition -> expr EQEQ expr
Rule 52    condition -> FALSE
Rule 53    condition -> TRUE
Rule 54    var_assign -> GLOBAL IDENTIFIER = condition
Rule 55    var_assign -> GLOBAL IDENTIFIER = expr
Rule 56    var_assign -> IDENTIFIER = condition
Rule 57    var_assign -> IDENTIFIER = expr

Terminals, with rules where they appear:

%                    : 42
(                    : 4 6 9 16 25 26 35
)                    : 4 6 9 16 25 26 35
*                    : 40
+                    : 7 7 44
,                    : 16 19
-                    : 36 43
/                    : 39
<                    : 46
=                    : 14 54 55 56 57
>                    : 50
ARGC                 : 29
ARGV                 : 28
ARRAY                : 14 30 31
ARROWOP              : 8 9 10
ASSERT               : 16
ELSE                 : 5
END                  : 15 18
EQEQ                 : 51
EQGTHAN              : 49
EQSTHAN              : 48
ERROR                : 18
EXCEPT               : 17
FALSE                : 52
FLOAT                : 32
FOR                  : 3
FUNCTION             : 25
GLOBAL               : 8 33 54 55
IDENTIFIER           : 3 7 8 9 10 14 18 19 25 26 33 34 54 55 56 57
IF                   : 6
IN                   : 3
INCLUDE              : 22
NOTEQ                : 47
NUMBER               : 37
PARAM                : 27
RETURN               : 23 24
STRING               : 22 38
THROW                : 19
TRUE                 : 53
TRY                  : 20
TYPEOF               : 45
WHILE                : 4
WRITE                : 11 12
^                    : 41
error                : 
{                    : 3 4 5 6 17 20 25
}                    : 15 21

Nonterminals, with rules where they appear:

condition            : 2 4 6 11 16 23 54 56
expr                 : 3 9 12 13 14 16 19 24 27 30 35 36 39 39 40 40 41 41 42 42 43 43 44 44 45 46 46 47 47 48 48 49 49 50 50 51 51 55 57
statement            : 0
var_assign           : 1


state 0

    (0) S' -> . statement
    (1) statement -> . var_assign
    (2) statement -> . condition
    (3) statement -> . FOR IDENTIFIER IN expr {
    (4) statement -> . WHILE ( condition ) {
    (5) statement -> . ELSE {
    (6) statement -> . IF ( condition ) {
    (7) statement -> . IDENTIFIER + +
    (8) statement -> . ARROWOP GLOBAL IDENTIFIER
    (9) statement -> . expr ARROWOP IDENTIFIER ( )
    (10) statement -> . ARROWOP IDENTIFIER
    (11) statement -> . WRITE condition
    (12) statement -> . WRITE expr
    (13) statement -> . expr
    (14) statement -> . IDENTIFIER ARRAY = expr
    (15) statement -> . } END
    (16) statement -> . ASSERT ( condition ) , expr
    (17) statement -> . EXCEPT {
    (18) statement -> . ERROR IDENTIFIER END
    (19) statement -> . THROW IDENTIFIER , expr
    (20) statement -> . TRY {
    (21) statement -> . }
    (22) statement -> . INCLUDE STRING
    (23) statement -> . RETURN condition
    (24) statement -> . RETURN expr
    (25) statement -> . FUNCTION IDENTIFIER ( ) {
    (54) var_assign -> . GLOBAL IDENTIFIER = condition
    (55) var_assign -> . GLOBAL IDENTIFIER = expr
    (56) var_assign -> . IDENTIFIER = condition
    (57) var_assign -> . IDENTIFIER = expr
    (46) condition -> . expr < expr
    (47) condition -> . expr NOTEQ expr
    (48) condition -> . expr EQSTHAN expr
    (49) condition -> . expr EQGTHAN expr
    (50) condition -> . expr > expr
    (51) condition -> . expr EQEQ expr
    (52) condition -> . FALSE
    (53) condition -> . TRUE
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    FOR             shift and go to state 4
    WHILE           shift and go to state 7
    ELSE            shift and go to state 9
    IF              shift and go to state 10
    IDENTIFIER      shift and go to state 5
    ARROWOP         shift and go to state 11
    WRITE           shift and go to state 13
    }               shift and go to state 15
    ASSERT          shift and go to state 16
    EXCEPT          shift and go to state 17
    ERROR           shift and go to state 18
    THROW           shift and go to state 19
    TRY             shift and go to state 20
    INCLUDE         shift and go to state 21
    RETURN          shift and go to state 23
    FUNCTION        shift and go to state 24
    GLOBAL          shift and go to state 12
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    statement                      shift and go to state 1
    var_assign                     shift and go to state 2
    condition                      shift and go to state 3
    expr                           shift and go to state 6

state 1

    (0) S' -> statement .


state 2

    (1) statement -> var_assign .
    $end            reduce using rule 1 (statement -> var_assign .)


state 3

    (2) statement -> condition .
    $end            reduce using rule 2 (statement -> condition .)


state 4

    (3) statement -> FOR . IDENTIFIER IN expr {
    IDENTIFIER      shift and go to state 34


state 5

    (7) statement -> IDENTIFIER . + +
    (14) statement -> IDENTIFIER . ARRAY = expr
    (56) var_assign -> IDENTIFIER . = condition
    (57) var_assign -> IDENTIFIER . = expr
    (26) expr -> IDENTIFIER . ( )
    (34) expr -> IDENTIFIER .
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for + resolved as shift
    +               shift and go to state 35
    ARRAY           shift and go to state 36
    =               shift and go to state 37
    (               shift and go to state 38
    ARROWOP         reduce using rule 34 (expr -> IDENTIFIER .)
    <               reduce using rule 34 (expr -> IDENTIFIER .)
    NOTEQ           reduce using rule 34 (expr -> IDENTIFIER .)
    EQSTHAN         reduce using rule 34 (expr -> IDENTIFIER .)
    EQGTHAN         reduce using rule 34 (expr -> IDENTIFIER .)
    >               reduce using rule 34 (expr -> IDENTIFIER .)
    EQEQ            reduce using rule 34 (expr -> IDENTIFIER .)
    /               reduce using rule 34 (expr -> IDENTIFIER .)
    *               reduce using rule 34 (expr -> IDENTIFIER .)
    ^               reduce using rule 34 (expr -> IDENTIFIER .)
    %               reduce using rule 34 (expr -> IDENTIFIER .)
    -               reduce using rule 34 (expr -> IDENTIFIER .)
    $end            reduce using rule 34 (expr -> IDENTIFIER .)


state 6

    (9) statement -> expr . ARROWOP IDENTIFIER ( )
    (13) statement -> expr .
    (46) condition -> expr . < expr
    (47) condition -> expr . NOTEQ expr
    (48) condition -> expr . EQSTHAN expr
    (49) condition -> expr . EQGTHAN expr
    (50) condition -> expr . > expr
    (51) condition -> expr . EQEQ expr
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    ARROWOP         shift and go to state 39
    $end            reduce using rule 13 (statement -> expr .)
    <               shift and go to state 40
    NOTEQ           shift and go to state 41
    EQSTHAN         shift and go to state 42
    EQGTHAN         shift and go to state 43
    >               shift and go to state 44
    EQEQ            shift and go to state 45
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 7

    (4) statement -> WHILE . ( condition ) {
    (               shift and go to state 53


state 8

    (35) expr -> ( . expr )
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 54

state 9

    (5) statement -> ELSE . {
    {               shift and go to state 57


state 10

    (6) statement -> IF . ( condition ) {
    (               shift and go to state 58


state 11

    (8) statement -> ARROWOP . GLOBAL IDENTIFIER
    (10) statement -> ARROWOP . IDENTIFIER
    GLOBAL          shift and go to state 59
    IDENTIFIER      shift and go to state 60


state 12

    (54) var_assign -> GLOBAL . IDENTIFIER = condition
    (55) var_assign -> GLOBAL . IDENTIFIER = expr
    (33) expr -> GLOBAL . IDENTIFIER
    IDENTIFIER      shift and go to state 61


state 13

    (11) statement -> WRITE . condition
    (12) statement -> WRITE . expr
    (46) condition -> . expr < expr
    (47) condition -> . expr NOTEQ expr
    (48) condition -> . expr EQSTHAN expr
    (49) condition -> . expr EQGTHAN expr
    (50) condition -> . expr > expr
    (51) condition -> . expr EQEQ expr
    (52) condition -> . FALSE
    (53) condition -> . TRUE
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    condition                      shift and go to state 62
    expr                           shift and go to state 63

state 14

    (31) expr -> ARRAY .
    ARROWOP         reduce using rule 31 (expr -> ARRAY .)
    <               reduce using rule 31 (expr -> ARRAY .)
    NOTEQ           reduce using rule 31 (expr -> ARRAY .)
    EQSTHAN         reduce using rule 31 (expr -> ARRAY .)
    EQGTHAN         reduce using rule 31 (expr -> ARRAY .)
    >               reduce using rule 31 (expr -> ARRAY .)
    EQEQ            reduce using rule 31 (expr -> ARRAY .)
    ARRAY           reduce using rule 31 (expr -> ARRAY .)
    /               reduce using rule 31 (expr -> ARRAY .)
    *               reduce using rule 31 (expr -> ARRAY .)
    ^               reduce using rule 31 (expr -> ARRAY .)
    %               reduce using rule 31 (expr -> ARRAY .)
    -               reduce using rule 31 (expr -> ARRAY .)
    +               reduce using rule 31 (expr -> ARRAY .)
    $end            reduce using rule 31 (expr -> ARRAY .)
    )               reduce using rule 31 (expr -> ARRAY .)
    {               reduce using rule 31 (expr -> ARRAY .)


state 15

    (15) statement -> } . END
    (21) statement -> } .
    END             shift and go to state 64
    $end            reduce using rule 21 (statement -> } .)


state 16

    (16) statement -> ASSERT . ( condition ) , expr
    (               shift and go to state 65


state 17

    (17) statement -> EXCEPT . {
    {               shift and go to state 66


state 18

    (18) statement -> ERROR . IDENTIFIER END
    IDENTIFIER      shift and go to state 67


state 19

    (19) statement -> THROW . IDENTIFIER , expr
    IDENTIFIER      shift and go to state 68


state 20

    (20) statement -> TRY . {
    {               shift and go to state 69


state 21

    (22) statement -> INCLUDE . STRING
    STRING          shift and go to state 70


state 22

    (38) expr -> STRING .
    ARROWOP         reduce using rule 38 (expr -> STRING .)
    <               reduce using rule 38 (expr -> STRING .)
    NOTEQ           reduce using rule 38 (expr -> STRING .)
    EQSTHAN         reduce using rule 38 (expr -> STRING .)
    EQGTHAN         reduce using rule 38 (expr -> STRING .)
    >               reduce using rule 38 (expr -> STRING .)
    EQEQ            reduce using rule 38 (expr -> STRING .)
    ARRAY           reduce using rule 38 (expr -> STRING .)
    /               reduce using rule 38 (expr -> STRING .)
    *               reduce using rule 38 (expr -> STRING .)
    ^               reduce using rule 38 (expr -> STRING .)
    %               reduce using rule 38 (expr -> STRING .)
    -               reduce using rule 38 (expr -> STRING .)
    +               reduce using rule 38 (expr -> STRING .)
    $end            reduce using rule 38 (expr -> STRING .)
    )               reduce using rule 38 (expr -> STRING .)
    {               reduce using rule 38 (expr -> STRING .)


state 23

    (23) statement -> RETURN . condition
    (24) statement -> RETURN . expr
    (46) condition -> . expr < expr
    (47) condition -> . expr NOTEQ expr
    (48) condition -> . expr EQSTHAN expr
    (49) condition -> . expr EQGTHAN expr
    (50) condition -> . expr > expr
    (51) condition -> . expr EQEQ expr
    (52) condition -> . FALSE
    (53) condition -> . TRUE
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    condition                      shift and go to state 71
    expr                           shift and go to state 72

state 24

    (25) statement -> FUNCTION . IDENTIFIER ( ) {
    IDENTIFIER      shift and go to state 73


state 25

    (52) condition -> FALSE .
    $end            reduce using rule 52 (condition -> FALSE .)
    )               reduce using rule 52 (condition -> FALSE .)


state 26

    (53) condition -> TRUE .
    $end            reduce using rule 53 (condition -> TRUE .)
    )               reduce using rule 53 (condition -> TRUE .)


state 27

    (27) expr -> PARAM . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 74

state 28

    (28) expr -> ARGV .
    ARROWOP         reduce using rule 28 (expr -> ARGV .)
    <               reduce using rule 28 (expr -> ARGV .)
    NOTEQ           reduce using rule 28 (expr -> ARGV .)
    EQSTHAN         reduce using rule 28 (expr -> ARGV .)
    EQGTHAN         reduce using rule 28 (expr -> ARGV .)
    >               reduce using rule 28 (expr -> ARGV .)
    EQEQ            reduce using rule 28 (expr -> ARGV .)
    ARRAY           reduce using rule 28 (expr -> ARGV .)
    /               reduce using rule 28 (expr -> ARGV .)
    *               reduce using rule 28 (expr -> ARGV .)
    ^               reduce using rule 28 (expr -> ARGV .)
    %               reduce using rule 28 (expr -> ARGV .)
    -               reduce using rule 28 (expr -> ARGV .)
    +               reduce using rule 28 (expr -> ARGV .)
    $end            reduce using rule 28 (expr -> ARGV .)
    )               reduce using rule 28 (expr -> ARGV .)
    {               reduce using rule 28 (expr -> ARGV .)


state 29

    (29) expr -> ARGC .
    ARROWOP         reduce using rule 29 (expr -> ARGC .)
    <               reduce using rule 29 (expr -> ARGC .)
    NOTEQ           reduce using rule 29 (expr -> ARGC .)
    EQSTHAN         reduce using rule 29 (expr -> ARGC .)
    EQGTHAN         reduce using rule 29 (expr -> ARGC .)
    >               reduce using rule 29 (expr -> ARGC .)
    EQEQ            reduce using rule 29 (expr -> ARGC .)
    ARRAY           reduce using rule 29 (expr -> ARGC .)
    /               reduce using rule 29 (expr -> ARGC .)
    *               reduce using rule 29 (expr -> ARGC .)
    ^               reduce using rule 29 (expr -> ARGC .)
    %               reduce using rule 29 (expr -> ARGC .)
    -               reduce using rule 29 (expr -> ARGC .)
    +               reduce using rule 29 (expr -> ARGC .)
    $end            reduce using rule 29 (expr -> ARGC .)
    )               reduce using rule 29 (expr -> ARGC .)
    {               reduce using rule 29 (expr -> ARGC .)


state 30

    (32) expr -> FLOAT .
    ARROWOP         reduce using rule 32 (expr -> FLOAT .)
    <               reduce using rule 32 (expr -> FLOAT .)
    NOTEQ           reduce using rule 32 (expr -> FLOAT .)
    EQSTHAN         reduce using rule 32 (expr -> FLOAT .)
    EQGTHAN         reduce using rule 32 (expr -> FLOAT .)
    >               reduce using rule 32 (expr -> FLOAT .)
    EQEQ            reduce using rule 32 (expr -> FLOAT .)
    ARRAY           reduce using rule 32 (expr -> FLOAT .)
    /               reduce using rule 32 (expr -> FLOAT .)
    *               reduce using rule 32 (expr -> FLOAT .)
    ^               reduce using rule 32 (expr -> FLOAT .)
    %               reduce using rule 32 (expr -> FLOAT .)
    -               reduce using rule 32 (expr -> FLOAT .)
    +               reduce using rule 32 (expr -> FLOAT .)
    $end            reduce using rule 32 (expr -> FLOAT .)
    )               reduce using rule 32 (expr -> FLOAT .)
    {               reduce using rule 32 (expr -> FLOAT .)


state 31

    (36) expr -> - . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 75

state 32

    (37) expr -> NUMBER .
    ARROWOP         reduce using rule 37 (expr -> NUMBER .)
    <               reduce using rule 37 (expr -> NUMBER .)
    NOTEQ           reduce using rule 37 (expr -> NUMBER .)
    EQSTHAN         reduce using rule 37 (expr -> NUMBER .)
    EQGTHAN         reduce using rule 37 (expr -> NUMBER .)
    >               reduce using rule 37 (expr -> NUMBER .)
    EQEQ            reduce using rule 37 (expr -> NUMBER .)
    ARRAY           reduce using rule 37 (expr -> NUMBER .)
    /               reduce using rule 37 (expr -> NUMBER .)
    *               reduce using rule 37 (expr -> NUMBER .)
    ^               reduce using rule 37 (expr -> NUMBER .)
    %               reduce using rule 37 (expr -> NUMBER .)
    -               reduce using rule 37 (expr -> NUMBER .)
    +               reduce using rule 37 (expr -> NUMBER .)
    $end            reduce using rule 37 (expr -> NUMBER .)
    )               reduce using rule 37 (expr -> NUMBER .)
    {               reduce using rule 37 (expr -> NUMBER .)


state 33

    (45) expr -> TYPEOF . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 76

state 34

    (3) statement -> FOR IDENTIFIER . IN expr {
    IN              shift and go to state 77


state 35

    (7) statement -> IDENTIFIER + . +
    +               shift and go to state 78


state 36

    (14) statement -> IDENTIFIER ARRAY . = expr
    =               shift and go to state 79


state 37

    (56) var_assign -> IDENTIFIER = . condition
    (57) var_assign -> IDENTIFIER = . expr
    (46) condition -> . expr < expr
    (47) condition -> . expr NOTEQ expr
    (48) condition -> . expr EQSTHAN expr
    (49) condition -> . expr EQGTHAN expr
    (50) condition -> . expr > expr
    (51) condition -> . expr EQEQ expr
    (52) condition -> . FALSE
    (53) condition -> . TRUE
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    condition                      shift and go to state 80
    expr                           shift and go to state 81

state 38

    (26) expr -> IDENTIFIER ( . )
    )               shift and go to state 82


state 39

    (9) statement -> expr ARROWOP . IDENTIFIER ( )
    IDENTIFIER      shift and go to state 83


state 40

    (46) condition -> expr < . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 84

state 41

    (47) condition -> expr NOTEQ . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 85

state 42

    (48) condition -> expr EQSTHAN . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 86

state 43

    (49) condition -> expr EQGTHAN . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 87

state 44

    (50) condition -> expr > . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 88

state 45

    (51) condition -> expr EQEQ . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 89

state 46

    (30) expr -> expr ARRAY .
    ARROWOP         reduce using rule 30 (expr -> expr ARRAY .)
    <               reduce using rule 30 (expr -> expr ARRAY .)
    NOTEQ           reduce using rule 30 (expr -> expr ARRAY .)
    EQSTHAN         reduce using rule 30 (expr -> expr ARRAY .)
    EQGTHAN         reduce using rule 30 (expr -> expr ARRAY .)
    >               reduce using rule 30 (expr -> expr ARRAY .)
    EQEQ            reduce using rule 30 (expr -> expr ARRAY .)
    ARRAY           reduce using rule 30 (expr -> expr ARRAY .)
    /               reduce using rule 30 (expr -> expr ARRAY .)
    *               reduce using rule 30 (expr -> expr ARRAY .)
    ^               reduce using rule 30 (expr -> expr ARRAY .)
    %               reduce using rule 30 (expr -> expr ARRAY .)
    -               reduce using rule 30 (expr -> expr ARRAY .)
    +               reduce using rule 30 (expr -> expr ARRAY .)
    $end            reduce using rule 30 (expr -> expr ARRAY .)
    )               reduce using rule 30 (expr -> expr ARRAY .)
    {               reduce using rule 30 (expr -> expr ARRAY .)


state 47

    (39) expr -> expr / . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 90

state 48

    (40) expr -> expr * . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 91

state 49

    (41) expr -> expr ^ . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 92

state 50

    (42) expr -> expr % . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 93

state 51

    (43) expr -> expr - . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 94

state 52

    (44) expr -> expr + . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 95

state 53

    (4) statement -> WHILE ( . condition ) {
    (46) condition -> . expr < expr
    (47) condition -> . expr NOTEQ expr
    (48) condition -> . expr EQSTHAN expr
    (49) condition -> . expr EQGTHAN expr
    (50) condition -> . expr > expr
    (51) condition -> . expr EQEQ expr
    (52) condition -> . FALSE
    (53) condition -> . TRUE
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    condition                      shift and go to state 96
    expr                           shift and go to state 97

state 54

    (35) expr -> ( expr . )
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    )               shift and go to state 98
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 55

    (26) expr -> IDENTIFIER . ( )
    (34) expr -> IDENTIFIER .
    (               shift and go to state 38
    )               reduce using rule 34 (expr -> IDENTIFIER .)
    ARRAY           reduce using rule 34 (expr -> IDENTIFIER .)
    /               reduce using rule 34 (expr -> IDENTIFIER .)
    *               reduce using rule 34 (expr -> IDENTIFIER .)
    ^               reduce using rule 34 (expr -> IDENTIFIER .)
    %               reduce using rule 34 (expr -> IDENTIFIER .)
    -               reduce using rule 34 (expr -> IDENTIFIER .)
    +               reduce using rule 34 (expr -> IDENTIFIER .)
    <               reduce using rule 34 (expr -> IDENTIFIER .)
    NOTEQ           reduce using rule 34 (expr -> IDENTIFIER .)
    EQSTHAN         reduce using rule 34 (expr -> IDENTIFIER .)
    EQGTHAN         reduce using rule 34 (expr -> IDENTIFIER .)
    >               reduce using rule 34 (expr -> IDENTIFIER .)
    EQEQ            reduce using rule 34 (expr -> IDENTIFIER .)
    $end            reduce using rule 34 (expr -> IDENTIFIER .)
    ARROWOP         reduce using rule 34 (expr -> IDENTIFIER .)
    {               reduce using rule 34 (expr -> IDENTIFIER .)


state 56

    (33) expr -> GLOBAL . IDENTIFIER
    IDENTIFIER      shift and go to state 99


state 57

    (5) statement -> ELSE { .
    $end            reduce using rule 5 (statement -> ELSE { .)


state 58

    (6) statement -> IF ( . condition ) {
    (46) condition -> . expr < expr
    (47) condition -> . expr NOTEQ expr
    (48) condition -> . expr EQSTHAN expr
    (49) condition -> . expr EQGTHAN expr
    (50) condition -> . expr > expr
    (51) condition -> . expr EQEQ expr
    (52) condition -> . FALSE
    (53) condition -> . TRUE
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    condition                      shift and go to state 100
    expr                           shift and go to state 97

state 59

    (8) statement -> ARROWOP GLOBAL . IDENTIFIER
    IDENTIFIER      shift and go to state 101


state 60

    (10) statement -> ARROWOP IDENTIFIER .
    $end            reduce using rule 10 (statement -> ARROWOP IDENTIFIER .)


state 61

    (54) var_assign -> GLOBAL IDENTIFIER . = condition
    (55) var_assign -> GLOBAL IDENTIFIER . = expr
    (33) expr -> GLOBAL IDENTIFIER .
    =               shift and go to state 102
    ARROWOP         reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    <               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    NOTEQ           reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    EQSTHAN         reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    EQGTHAN         reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    >               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    EQEQ            reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    ARRAY           reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    /               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    *               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    ^               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    %               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    -               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    +               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    $end            reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)


state 62

    (11) statement -> WRITE condition .
    $end            reduce using rule 11 (statement -> WRITE condition .)


state 63

    (12) statement -> WRITE expr .
    (46) condition -> expr . < expr
    (47) condition -> expr . NOTEQ expr
    (48) condition -> expr . EQSTHAN expr
    (49) condition -> expr . EQGTHAN expr
    (50) condition -> expr . > expr
    (51) condition -> expr . EQEQ expr
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 12 (statement -> WRITE expr .)
    <               shift and go to state 40
    NOTEQ           shift and go to state 41
    EQSTHAN         shift and go to state 42
    EQGTHAN         shift and go to state 43
    >               shift and go to state 44
    EQEQ            shift and go to state 45
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 64

    (15) statement -> } END .
    $end            reduce using rule 15 (statement -> } END .)


state 65

    (16) statement -> ASSERT ( . condition ) , expr
    (46) condition -> . expr < expr
    (47) condition -> . expr NOTEQ expr
    (48) condition -> . expr EQSTHAN expr
    (49) condition -> . expr EQGTHAN expr
    (50) condition -> . expr > expr
    (51) condition -> . expr EQEQ expr
    (52) condition -> . FALSE
    (53) condition -> . TRUE
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    condition                      shift and go to state 103
    expr                           shift and go to state 97

state 66

    (17) statement -> EXCEPT { .
    $end            reduce using rule 17 (statement -> EXCEPT { .)


state 67

    (18) statement -> ERROR IDENTIFIER . END
    END             shift and go to state 104


state 68

    (19) statement -> THROW IDENTIFIER . , expr
    ,               shift and go to state 105


state 69

    (20) statement -> TRY { .
    $end            reduce using rule 20 (statement -> TRY { .)


state 70

    (22) statement -> INCLUDE STRING .
    $end            reduce using rule 22 (statement -> INCLUDE STRING .)


state 71

    (23) statement -> RETURN condition .
    $end            reduce using rule 23 (statement -> RETURN condition .)


state 72

    (24) statement -> RETURN expr .
    (46) condition -> expr . < expr
    (47) condition -> expr . NOTEQ expr
    (48) condition -> expr . EQSTHAN expr
    (49) condition -> expr . EQGTHAN expr
    (50) condition -> expr . > expr
    (51) condition -> expr . EQEQ expr
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 24 (statement -> RETURN expr .)
    <               shift and go to state 40
    NOTEQ           shift and go to state 41
    EQSTHAN         shift and go to state 42
    EQGTHAN         shift and go to state 43
    >               shift and go to state 44
    EQEQ            shift and go to state 45
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 73

    (25) statement -> FUNCTION IDENTIFIER . ( ) {
    (               shift and go to state 106


state 74

    (27) expr -> PARAM expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ARROWOP         reduce using rule 27 (expr -> PARAM expr .)
    <               reduce using rule 27 (expr -> PARAM expr .)
    NOTEQ           reduce using rule 27 (expr -> PARAM expr .)
    EQSTHAN         reduce using rule 27 (expr -> PARAM expr .)
    EQGTHAN         reduce using rule 27 (expr -> PARAM expr .)
    >               reduce using rule 27 (expr -> PARAM expr .)
    EQEQ            reduce using rule 27 (expr -> PARAM expr .)
    $end            reduce using rule 27 (expr -> PARAM expr .)
    )               reduce using rule 27 (expr -> PARAM expr .)
    {               reduce using rule 27 (expr -> PARAM expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 75

    (36) expr -> - expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    ARROWOP         reduce using rule 36 (expr -> - expr .)
    <               reduce using rule 36 (expr -> - expr .)
    NOTEQ           reduce using rule 36 (expr -> - expr .)
    EQSTHAN         reduce using rule 36 (expr -> - expr .)
    EQGTHAN         reduce using rule 36 (expr -> - expr .)
    >               reduce using rule 36 (expr -> - expr .)
    EQEQ            reduce using rule 36 (expr -> - expr .)
    ARRAY           reduce using rule 36 (expr -> - expr .)
    /               reduce using rule 36 (expr -> - expr .)
    *               reduce using rule 36 (expr -> - expr .)
    ^               reduce using rule 36 (expr -> - expr .)
    %               reduce using rule 36 (expr -> - expr .)
    -               reduce using rule 36 (expr -> - expr .)
    +               reduce using rule 36 (expr -> - expr .)
    $end            reduce using rule 36 (expr -> - expr .)
    )               reduce using rule 36 (expr -> - expr .)
    {               reduce using rule 36 (expr -> - expr .)


state 76

    (45) expr -> TYPEOF expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ARROWOP         reduce using rule 45 (expr -> TYPEOF expr .)
    <               reduce using rule 45 (expr -> TYPEOF expr .)
    NOTEQ           reduce using rule 45 (expr -> TYPEOF expr .)
    EQSTHAN         reduce using rule 45 (expr -> TYPEOF expr .)
    EQGTHAN         reduce using rule 45 (expr -> TYPEOF expr .)
    >               reduce using rule 45 (expr -> TYPEOF expr .)
    EQEQ            reduce using rule 45 (expr -> TYPEOF expr .)
    $end            reduce using rule 45 (expr -> TYPEOF expr .)
    )               reduce using rule 45 (expr -> TYPEOF expr .)
    {               reduce using rule 45 (expr -> TYPEOF expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 77

    (3) statement -> FOR IDENTIFIER IN . expr {
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 107

state 78

    (7) statement -> IDENTIFIER + + .
    $end            reduce using rule 7 (statement -> IDENTIFIER + + .)


state 79

    (14) statement -> IDENTIFIER ARRAY = . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 108

state 80

    (56) var_assign -> IDENTIFIER = condition .
    $end            reduce using rule 56 (var_assign -> IDENTIFIER = condition .)


state 81

    (57) var_assign -> IDENTIFIER = expr .
    (46) condition -> expr . < expr
    (47) condition -> expr . NOTEQ expr
    (48) condition -> expr . EQSTHAN expr
    (49) condition -> expr . EQGTHAN expr
    (50) condition -> expr . > expr
    (51) condition -> expr . EQEQ expr
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 57 (var_assign -> IDENTIFIER = expr .)
    <               shift and go to state 40
    NOTEQ           shift and go to state 41
    EQSTHAN         shift and go to state 42
    EQGTHAN         shift and go to state 43
    >               shift and go to state 44
    EQEQ            shift and go to state 45
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 82

    (26) expr -> IDENTIFIER ( ) .
    ARROWOP         reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    <               reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    NOTEQ           reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    EQSTHAN         reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    EQGTHAN         reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    >               reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    EQEQ            reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    ARRAY           reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    /               reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    *               reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    ^               reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    %               reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    -               reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    +               reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    $end            reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    )               reduce using rule 26 (expr -> IDENTIFIER ( ) .)
    {               reduce using rule 26 (expr -> IDENTIFIER ( ) .)


state 83

    (9) statement -> expr ARROWOP IDENTIFIER . ( )
    (               shift and go to state 109


state 84

    (46) condition -> expr < expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 46 (condition -> expr < expr .)
    )               reduce using rule 46 (condition -> expr < expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 85

    (47) condition -> expr NOTEQ expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 47 (condition -> expr NOTEQ expr .)
    )               reduce using rule 47 (condition -> expr NOTEQ expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 86

    (48) condition -> expr EQSTHAN expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 48 (condition -> expr EQSTHAN expr .)
    )               reduce using rule 48 (condition -> expr EQSTHAN expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 87

    (49) condition -> expr EQGTHAN expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 49 (condition -> expr EQGTHAN expr .)
    )               reduce using rule 49 (condition -> expr EQGTHAN expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 88

    (50) condition -> expr > expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 50 (condition -> expr > expr .)
    )               reduce using rule 50 (condition -> expr > expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 89

    (51) condition -> expr EQEQ expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 51 (condition -> expr EQEQ expr .)
    )               reduce using rule 51 (condition -> expr EQEQ expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 90

    (39) expr -> expr / expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    ARROWOP         reduce using rule 39 (expr -> expr / expr .)
    <               reduce using rule 39 (expr -> expr / expr .)
    NOTEQ           reduce using rule 39 (expr -> expr / expr .)
    EQSTHAN         reduce using rule 39 (expr -> expr / expr .)
    EQGTHAN         reduce using rule 39 (expr -> expr / expr .)
    >               reduce using rule 39 (expr -> expr / expr .)
    EQEQ            reduce using rule 39 (expr -> expr / expr .)
    ARRAY           reduce using rule 39 (expr -> expr / expr .)
    /               reduce using rule 39 (expr -> expr / expr .)
    *               reduce using rule 39 (expr -> expr / expr .)
    ^               reduce using rule 39 (expr -> expr / expr .)
    %               reduce using rule 39 (expr -> expr / expr .)
    -               reduce using rule 39 (expr -> expr / expr .)
    +               reduce using rule 39 (expr -> expr / expr .)
    $end            reduce using rule 39 (expr -> expr / expr .)
    )               reduce using rule 39 (expr -> expr / expr .)
    {               reduce using rule 39 (expr -> expr / expr .)


state 91

    (40) expr -> expr * expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    ARROWOP         reduce using rule 40 (expr -> expr * expr .)
    <               reduce using rule 40 (expr -> expr * expr .)
    NOTEQ           reduce using rule 40 (expr -> expr * expr .)
    EQSTHAN         reduce using rule 40 (expr -> expr * expr .)
    EQGTHAN         reduce using rule 40 (expr -> expr * expr .)
    >               reduce using rule 40 (expr -> expr * expr .)
    EQEQ            reduce using rule 40 (expr -> expr * expr .)
    ARRAY           reduce using rule 40 (expr -> expr * expr .)
    /               reduce using rule 40 (expr -> expr * expr .)
    *               reduce using rule 40 (expr -> expr * expr .)
    ^               reduce using rule 40 (expr -> expr * expr .)
    %               reduce using rule 40 (expr -> expr * expr .)
    -               reduce using rule 40 (expr -> expr * expr .)
    +               reduce using rule 40 (expr -> expr * expr .)
    $end            reduce using rule 40 (expr -> expr * expr .)
    )               reduce using rule 40 (expr -> expr * expr .)
    {               reduce using rule 40 (expr -> expr * expr .)


state 92

    (41) expr -> expr ^ expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ARROWOP         reduce using rule 41 (expr -> expr ^ expr .)
    <               reduce using rule 41 (expr -> expr ^ expr .)
    NOTEQ           reduce using rule 41 (expr -> expr ^ expr .)
    EQSTHAN         reduce using rule 41 (expr -> expr ^ expr .)
    EQGTHAN         reduce using rule 41 (expr -> expr ^ expr .)
    >               reduce using rule 41 (expr -> expr ^ expr .)
    EQEQ            reduce using rule 41 (expr -> expr ^ expr .)
    $end            reduce using rule 41 (expr -> expr ^ expr .)
    )               reduce using rule 41 (expr -> expr ^ expr .)
    {               reduce using rule 41 (expr -> expr ^ expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 93

    (42) expr -> expr % expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ARROWOP         reduce using rule 42 (expr -> expr % expr .)
    <               reduce using rule 42 (expr -> expr % expr .)
    NOTEQ           reduce using rule 42 (expr -> expr % expr .)
    EQSTHAN         reduce using rule 42 (expr -> expr % expr .)
    EQGTHAN         reduce using rule 42 (expr -> expr % expr .)
    >               reduce using rule 42 (expr -> expr % expr .)
    EQEQ            reduce using rule 42 (expr -> expr % expr .)
    $end            reduce using rule 42 (expr -> expr % expr .)
    )               reduce using rule 42 (expr -> expr % expr .)
    {               reduce using rule 42 (expr -> expr % expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 94

    (43) expr -> expr - expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    ARROWOP         reduce using rule 43 (expr -> expr - expr .)
    <               reduce using rule 43 (expr -> expr - expr .)
    NOTEQ           reduce using rule 43 (expr -> expr - expr .)
    EQSTHAN         reduce using rule 43 (expr -> expr - expr .)
    EQGTHAN         reduce using rule 43 (expr -> expr - expr .)
    >               reduce using rule 43 (expr -> expr - expr .)
    EQEQ            reduce using rule 43 (expr -> expr - expr .)
    ARRAY           reduce using rule 43 (expr -> expr - expr .)
    ^               reduce using rule 43 (expr -> expr - expr .)
    %               reduce using rule 43 (expr -> expr - expr .)
    -               reduce using rule 43 (expr -> expr - expr .)
    +               reduce using rule 43 (expr -> expr - expr .)
    $end            reduce using rule 43 (expr -> expr - expr .)
    )               reduce using rule 43 (expr -> expr - expr .)
    {               reduce using rule 43 (expr -> expr - expr .)
    /               shift and go to state 47
    *               shift and go to state 48


state 95

    (44) expr -> expr + expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    ARROWOP         reduce using rule 44 (expr -> expr + expr .)
    <               reduce using rule 44 (expr -> expr + expr .)
    NOTEQ           reduce using rule 44 (expr -> expr + expr .)
    EQSTHAN         reduce using rule 44 (expr -> expr + expr .)
    EQGTHAN         reduce using rule 44 (expr -> expr + expr .)
    >               reduce using rule 44 (expr -> expr + expr .)
    EQEQ            reduce using rule 44 (expr -> expr + expr .)
    ARRAY           reduce using rule 44 (expr -> expr + expr .)
    ^               reduce using rule 44 (expr -> expr + expr .)
    %               reduce using rule 44 (expr -> expr + expr .)
    -               reduce using rule 44 (expr -> expr + expr .)
    +               reduce using rule 44 (expr -> expr + expr .)
    $end            reduce using rule 44 (expr -> expr + expr .)
    )               reduce using rule 44 (expr -> expr + expr .)
    {               reduce using rule 44 (expr -> expr + expr .)
    /               shift and go to state 47
    *               shift and go to state 48


state 96

    (4) statement -> WHILE ( condition . ) {
    )               shift and go to state 110


state 97

    (46) condition -> expr . < expr
    (47) condition -> expr . NOTEQ expr
    (48) condition -> expr . EQSTHAN expr
    (49) condition -> expr . EQGTHAN expr
    (50) condition -> expr . > expr
    (51) condition -> expr . EQEQ expr
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    <               shift and go to state 40
    NOTEQ           shift and go to state 41
    EQSTHAN         shift and go to state 42
    EQGTHAN         shift and go to state 43
    >               shift and go to state 44
    EQEQ            shift and go to state 45
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 98

    (35) expr -> ( expr ) .
    ARROWOP         reduce using rule 35 (expr -> ( expr ) .)
    <               reduce using rule 35 (expr -> ( expr ) .)
    NOTEQ           reduce using rule 35 (expr -> ( expr ) .)
    EQSTHAN         reduce using rule 35 (expr -> ( expr ) .)
    EQGTHAN         reduce using rule 35 (expr -> ( expr ) .)
    >               reduce using rule 35 (expr -> ( expr ) .)
    EQEQ            reduce using rule 35 (expr -> ( expr ) .)
    ARRAY           reduce using rule 35 (expr -> ( expr ) .)
    /               reduce using rule 35 (expr -> ( expr ) .)
    *               reduce using rule 35 (expr -> ( expr ) .)
    ^               reduce using rule 35 (expr -> ( expr ) .)
    %               reduce using rule 35 (expr -> ( expr ) .)
    -               reduce using rule 35 (expr -> ( expr ) .)
    +               reduce using rule 35 (expr -> ( expr ) .)
    $end            reduce using rule 35 (expr -> ( expr ) .)
    )               reduce using rule 35 (expr -> ( expr ) .)
    {               reduce using rule 35 (expr -> ( expr ) .)


state 99

    (33) expr -> GLOBAL IDENTIFIER .
    )               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    ARRAY           reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    /               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    *               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    ^               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    %               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    -               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    +               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    <               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    NOTEQ           reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    EQSTHAN         reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    EQGTHAN         reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    >               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    EQEQ            reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    $end            reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    ARROWOP         reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)
    {               reduce using rule 33 (expr -> GLOBAL IDENTIFIER .)


state 100

    (6) statement -> IF ( condition . ) {
    )               shift and go to state 111


state 101

    (8) statement -> ARROWOP GLOBAL IDENTIFIER .
    $end            reduce using rule 8 (statement -> ARROWOP GLOBAL IDENTIFIER .)


state 102

    (54) var_assign -> GLOBAL IDENTIFIER = . condition
    (55) var_assign -> GLOBAL IDENTIFIER = . expr
    (46) condition -> . expr < expr
    (47) condition -> . expr NOTEQ expr
    (48) condition -> . expr EQSTHAN expr
    (49) condition -> . expr EQGTHAN expr
    (50) condition -> . expr > expr
    (51) condition -> . expr EQEQ expr
    (52) condition -> . FALSE
    (53) condition -> . TRUE
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    condition                      shift and go to state 112
    expr                           shift and go to state 113

state 103

    (16) statement -> ASSERT ( condition . ) , expr
    )               shift and go to state 114


state 104

    (18) statement -> ERROR IDENTIFIER END .
    $end            reduce using rule 18 (statement -> ERROR IDENTIFIER END .)


state 105

    (19) statement -> THROW IDENTIFIER , . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 115

state 106

    (25) statement -> FUNCTION IDENTIFIER ( . ) {
    )               shift and go to state 116


state 107

    (3) statement -> FOR IDENTIFIER IN expr . {
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    {               shift and go to state 117
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 108

    (14) statement -> IDENTIFIER ARRAY = expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 14 (statement -> IDENTIFIER ARRAY = expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 109

    (9) statement -> expr ARROWOP IDENTIFIER ( . )
    )               shift and go to state 118


state 110

    (4) statement -> WHILE ( condition ) . {
    {               shift and go to state 119


state 111

    (6) statement -> IF ( condition ) . {
    {               shift and go to state 120


state 112

    (54) var_assign -> GLOBAL IDENTIFIER = condition .
    $end            reduce using rule 54 (var_assign -> GLOBAL IDENTIFIER = condition .)


state 113

    (55) var_assign -> GLOBAL IDENTIFIER = expr .
    (46) condition -> expr . < expr
    (47) condition -> expr . NOTEQ expr
    (48) condition -> expr . EQSTHAN expr
    (49) condition -> expr . EQGTHAN expr
    (50) condition -> expr . > expr
    (51) condition -> expr . EQEQ expr
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 55 (var_assign -> GLOBAL IDENTIFIER = expr .)
    <               shift and go to state 40
    NOTEQ           shift and go to state 41
    EQSTHAN         shift and go to state 42
    EQGTHAN         shift and go to state 43
    >               shift and go to state 44
    EQEQ            shift and go to state 45
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 114

    (16) statement -> ASSERT ( condition ) . , expr
    ,               shift and go to state 121


state 115

    (19) statement -> THROW IDENTIFIER , expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 19 (statement -> THROW IDENTIFIER , expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 116

    (25) statement -> FUNCTION IDENTIFIER ( ) . {
    {               shift and go to state 122


state 117

    (3) statement -> FOR IDENTIFIER IN expr { .
    $end            reduce using rule 3 (statement -> FOR IDENTIFIER IN expr { .)


state 118

    (9) statement -> expr ARROWOP IDENTIFIER ( ) .
    $end            reduce using rule 9 (statement -> expr ARROWOP IDENTIFIER ( ) .)


state 119

    (4) statement -> WHILE ( condition ) { .
    $end            reduce using rule 4 (statement -> WHILE ( condition ) { .)


state 120

    (6) statement -> IF ( condition ) { .
    $end            reduce using rule 6 (statement -> IF ( condition ) { .)


state 121

    (16) statement -> ASSERT ( condition ) , . expr
    (26) expr -> . IDENTIFIER ( )
    (27) expr -> . PARAM expr
    (28) expr -> . ARGV
    (29) expr -> . ARGC
    (30) expr -> . expr ARRAY
    (31) expr -> . ARRAY
    (32) expr -> . FLOAT
    (33) expr -> . GLOBAL IDENTIFIER
    (34) expr -> . IDENTIFIER
    (35) expr -> . ( expr )
    (36) expr -> . - expr
    (37) expr -> . NUMBER
    (38) expr -> . STRING
    (39) expr -> . expr / expr
    (40) expr -> . expr * expr
    (41) expr -> . expr ^ expr
    (42) expr -> . expr % expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 55
    PARAM           shift and go to state 27
    ARGV            shift and go to state 28
    ARGC            shift and go to state 29
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 30
    GLOBAL          shift and go to state 56
    (               shift and go to state 8
    -               shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 22
    TYPEOF          shift and go to state 33

    expr                           shift and go to state 123

state 122

    (25) statement -> FUNCTION IDENTIFIER ( ) { .
    $end            reduce using rule 25 (statement -> FUNCTION IDENTIFIER ( ) { .)


state 123

    (16) statement -> ASSERT ( condition ) , expr .
    (30) expr -> expr . ARRAY
    (39) expr -> expr . / expr
    (40) expr -> expr . * expr
    (41) expr -> expr . ^ expr
    (42) expr -> expr . % expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    $end            reduce using rule 16 (statement -> ASSERT ( condition ) , expr .)
    ARRAY           shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    ^               shift and go to state 49
    %               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


Conflicts:

shift/reduce conflict for ARRAY in state 5 resolved as shift
shift/reduce conflict for + in state 5 resolved as shift
shift/reduce conflict for ARRAY in state 74 resolved as shift
shift/reduce conflict for / in state 74 resolved as shift
shift/reduce conflict for * in state 74 resolved as shift
shift/reduce conflict for ^ in state 74 resolved as shift
shift/reduce conflict for % in state 74 resolved as shift
shift/reduce conflict for - in state 74 resolved as shift
shift/reduce conflict for + in state 74 resolved as shift
shift/reduce conflict for ARRAY in state 76 resolved as shift
shift/reduce conflict for / in state 76 resolved as shift
shift/reduce conflict for * in state 76 resolved as shift
shift/reduce conflict for ^ in state 76 resolved as shift
shift/reduce conflict for % in state 76 resolved as shift
shift/reduce conflict for - in state 76 resolved as shift
shift/reduce conflict for + in state 76 resolved as shift
shift/reduce conflict for ARRAY in state 92 resolved as shift
shift/reduce conflict for / in state 92 resolved as shift
shift/reduce conflict for * in state 92 resolved as shift
shift/reduce conflict for ^ in state 92 resolved as shift
shift/reduce conflict for % in state 92 resolved as shift
shift/reduce conflict for - in state 92 resolved as shift
shift/reduce conflict for + in state 92 resolved as shift
shift/reduce conflict for ARRAY in state 93 resolved as shift
shift/reduce conflict for / in state 93 resolved as shift
shift/reduce conflict for * in state 93 resolved as shift
shift/reduce conflict for ^ in state 93 resolved as shift
shift/reduce conflict for % in state 93 resolved as shift
shift/reduce conflict for - in state 93 resolved as shift
shift/reduce conflict for + in state 93 resolved as shift