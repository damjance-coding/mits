Grammar:

Rule 0     S' -> statement
Rule 1     statement -> var_assign
Rule 2     statement -> condition
Rule 3     statement -> FOR IDENTIFIER IN expr {
Rule 4     statement -> WHILE ( condition ) {
Rule 5     statement -> ELSE {
Rule 6     statement -> IF ( condition ) {
Rule 7     statement -> IDENTIFIER + +  [precedence=left, level=1]
Rule 8     statement -> ARROWOP GLOBAL IDENTIFIER
Rule 9     statement -> expr ARROWOP IDENTIFIER ( )
Rule 10    statement -> ARROWOP IDENTIFIER
Rule 11    statement -> WRITE condition
Rule 12    statement -> WRITE expr
Rule 13    statement -> expr
Rule 14    statement -> IDENTIFIER ARRAY = expr
Rule 15    statement -> }
Rule 16    statement -> MACRO IDENTIFIER : IDENTIFIER ( ) {
Rule 17    statement -> GLOBAL MACRO IDENTIFIER {
Rule 18    statement -> } END
Rule 19    statement -> INCLUDE STRING
Rule 20    statement -> RETURN expr
Rule 21    statement -> FUNCTION IDENTIFIER ( ) {
Rule 22    expr -> IDENTIFIER ( )
Rule 23    expr -> PARAM expr
Rule 24    expr -> ARGV
Rule 25    expr -> ARGC
Rule 26    expr -> expr ARRAY
Rule 27    expr -> ARRAY
Rule 28    expr -> FLOAT
Rule 29    expr -> GLOBAL IDENTIFIER
Rule 30    expr -> IDENTIFIER
Rule 31    expr -> ( expr )
Rule 32    expr -> - expr  [precedence=right, level=3]
Rule 33    expr -> NUMBER
Rule 34    expr -> STRING
Rule 35    expr -> expr / expr  [precedence=left, level=2]
Rule 36    expr -> expr * expr  [precedence=left, level=2]
Rule 37    expr -> expr - expr  [precedence=left, level=1]
Rule 38    expr -> expr + expr  [precedence=left, level=1]
Rule 39    expr -> TYPEOF expr
Rule 40    var_assign -> GLOBAL IDENTIFIER = condition
Rule 41    var_assign -> GLOBAL IDENTIFIER = expr
Rule 42    var_assign -> IDENTIFIER = condition
Rule 43    var_assign -> IDENTIFIER = expr
Rule 44    condition -> expr < expr
Rule 45    condition -> expr NOTEQ expr
Rule 46    condition -> expr EQSTHAN expr
Rule 47    condition -> expr EQGTHAN expr
Rule 48    condition -> expr > expr
Rule 49    condition -> expr EQEQ expr

Terminals, with rules where they appear:

(                    : 4 6 9 16 21 22 31
)                    : 4 6 9 16 21 22 31
*                    : 36
+                    : 7 7 38
-                    : 32 37
/                    : 35
:                    : 16
<                    : 44
=                    : 14 40 41 42 43
>                    : 48
ARGC                 : 25
ARGV                 : 24
ARRAY                : 14 26 27
ARROWOP              : 8 9 10
ELSE                 : 5
END                  : 18
EQEQ                 : 49
EQGTHAN              : 47
EQSTHAN              : 46
FLOAT                : 28
FOR                  : 3
FUNCTION             : 21
GLOBAL               : 8 17 29 40 41
IDENTIFIER           : 3 7 8 9 10 14 16 16 17 21 22 29 30 40 41 42 43
IF                   : 6
IN                   : 3
INCLUDE              : 19
MACRO                : 16 17
NOTEQ                : 45
NUMBER               : 33
PARAM                : 23
RETURN               : 20
STRING               : 19 34
TYPEOF               : 39
WHILE                : 4
WRITE                : 11 12
error                : 
{                    : 3 4 5 6 16 17 21
}                    : 15 18

Nonterminals, with rules where they appear:

condition            : 2 4 6 11 40 42
expr                 : 3 9 12 13 14 20 23 26 31 32 35 35 36 36 37 37 38 38 39 41 43 44 44 45 45 46 46 47 47 48 48 49 49
statement            : 0
var_assign           : 1


state 0

    (0) S' -> . statement
    (1) statement -> . var_assign
    (2) statement -> . condition
    (3) statement -> . FOR IDENTIFIER IN expr {
    (4) statement -> . WHILE ( condition ) {
    (5) statement -> . ELSE {
    (6) statement -> . IF ( condition ) {
    (7) statement -> . IDENTIFIER + +
    (8) statement -> . ARROWOP GLOBAL IDENTIFIER
    (9) statement -> . expr ARROWOP IDENTIFIER ( )
    (10) statement -> . ARROWOP IDENTIFIER
    (11) statement -> . WRITE condition
    (12) statement -> . WRITE expr
    (13) statement -> . expr
    (14) statement -> . IDENTIFIER ARRAY = expr
    (15) statement -> . }
    (16) statement -> . MACRO IDENTIFIER : IDENTIFIER ( ) {
    (17) statement -> . GLOBAL MACRO IDENTIFIER {
    (18) statement -> . } END
    (19) statement -> . INCLUDE STRING
    (20) statement -> . RETURN expr
    (21) statement -> . FUNCTION IDENTIFIER ( ) {
    (40) var_assign -> . GLOBAL IDENTIFIER = condition
    (41) var_assign -> . GLOBAL IDENTIFIER = expr
    (42) var_assign -> . IDENTIFIER = condition
    (43) var_assign -> . IDENTIFIER = expr
    (44) condition -> . expr < expr
    (45) condition -> . expr NOTEQ expr
    (46) condition -> . expr EQSTHAN expr
    (47) condition -> . expr EQGTHAN expr
    (48) condition -> . expr > expr
    (49) condition -> . expr EQEQ expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    FOR             shift and go to state 4
    WHILE           shift and go to state 7
    ELSE            shift and go to state 9
    IF              shift and go to state 10
    IDENTIFIER      shift and go to state 5
    ARROWOP         shift and go to state 11
    WRITE           shift and go to state 13
    }               shift and go to state 15
    MACRO           shift and go to state 16
    GLOBAL          shift and go to state 12
    INCLUDE         shift and go to state 17
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    statement                      shift and go to state 1
    var_assign                     shift and go to state 2
    condition                      shift and go to state 3
    expr                           shift and go to state 6

state 1

    (0) S' -> statement .


state 2

    (1) statement -> var_assign .
    $end            reduce using rule 1 (statement -> var_assign .)


state 3

    (2) statement -> condition .
    $end            reduce using rule 2 (statement -> condition .)


state 4

    (3) statement -> FOR . IDENTIFIER IN expr {
    IDENTIFIER      shift and go to state 28


state 5

    (7) statement -> IDENTIFIER . + +
    (14) statement -> IDENTIFIER . ARRAY = expr
    (42) var_assign -> IDENTIFIER . = condition
    (43) var_assign -> IDENTIFIER . = expr
    (22) expr -> IDENTIFIER . ( )
    (30) expr -> IDENTIFIER .
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for + resolved as shift
    +               shift and go to state 29
    ARRAY           shift and go to state 30
    =               shift and go to state 31
    (               shift and go to state 32
    ARROWOP         reduce using rule 30 (expr -> IDENTIFIER .)
    <               reduce using rule 30 (expr -> IDENTIFIER .)
    NOTEQ           reduce using rule 30 (expr -> IDENTIFIER .)
    EQSTHAN         reduce using rule 30 (expr -> IDENTIFIER .)
    EQGTHAN         reduce using rule 30 (expr -> IDENTIFIER .)
    >               reduce using rule 30 (expr -> IDENTIFIER .)
    EQEQ            reduce using rule 30 (expr -> IDENTIFIER .)
    /               reduce using rule 30 (expr -> IDENTIFIER .)
    *               reduce using rule 30 (expr -> IDENTIFIER .)
    -               reduce using rule 30 (expr -> IDENTIFIER .)
    $end            reduce using rule 30 (expr -> IDENTIFIER .)


state 6

    (9) statement -> expr . ARROWOP IDENTIFIER ( )
    (13) statement -> expr .
    (44) condition -> expr . < expr
    (45) condition -> expr . NOTEQ expr
    (46) condition -> expr . EQSTHAN expr
    (47) condition -> expr . EQGTHAN expr
    (48) condition -> expr . > expr
    (49) condition -> expr . EQEQ expr
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    ARROWOP         shift and go to state 33
    $end            reduce using rule 13 (statement -> expr .)
    <               shift and go to state 34
    NOTEQ           shift and go to state 35
    EQSTHAN         shift and go to state 36
    EQGTHAN         shift and go to state 37
    >               shift and go to state 38
    EQEQ            shift and go to state 39
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 7

    (4) statement -> WHILE . ( condition ) {
    (               shift and go to state 45


state 8

    (31) expr -> ( . expr )
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 46

state 9

    (5) statement -> ELSE . {
    {               shift and go to state 49


state 10

    (6) statement -> IF . ( condition ) {
    (               shift and go to state 50


state 11

    (8) statement -> ARROWOP . GLOBAL IDENTIFIER
    (10) statement -> ARROWOP . IDENTIFIER
    GLOBAL          shift and go to state 51
    IDENTIFIER      shift and go to state 52


state 12

    (17) statement -> GLOBAL . MACRO IDENTIFIER {
    (40) var_assign -> GLOBAL . IDENTIFIER = condition
    (41) var_assign -> GLOBAL . IDENTIFIER = expr
    (29) expr -> GLOBAL . IDENTIFIER
    MACRO           shift and go to state 53
    IDENTIFIER      shift and go to state 54


state 13

    (11) statement -> WRITE . condition
    (12) statement -> WRITE . expr
    (44) condition -> . expr < expr
    (45) condition -> . expr NOTEQ expr
    (46) condition -> . expr EQSTHAN expr
    (47) condition -> . expr EQGTHAN expr
    (48) condition -> . expr > expr
    (49) condition -> . expr EQEQ expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    condition                      shift and go to state 55
    expr                           shift and go to state 56

state 14

    (27) expr -> ARRAY .
    ARROWOP         reduce using rule 27 (expr -> ARRAY .)
    <               reduce using rule 27 (expr -> ARRAY .)
    NOTEQ           reduce using rule 27 (expr -> ARRAY .)
    EQSTHAN         reduce using rule 27 (expr -> ARRAY .)
    EQGTHAN         reduce using rule 27 (expr -> ARRAY .)
    >               reduce using rule 27 (expr -> ARRAY .)
    EQEQ            reduce using rule 27 (expr -> ARRAY .)
    ARRAY           reduce using rule 27 (expr -> ARRAY .)
    /               reduce using rule 27 (expr -> ARRAY .)
    *               reduce using rule 27 (expr -> ARRAY .)
    -               reduce using rule 27 (expr -> ARRAY .)
    +               reduce using rule 27 (expr -> ARRAY .)
    $end            reduce using rule 27 (expr -> ARRAY .)
    )               reduce using rule 27 (expr -> ARRAY .)
    {               reduce using rule 27 (expr -> ARRAY .)


state 15

    (15) statement -> } .
    (18) statement -> } . END
    $end            reduce using rule 15 (statement -> } .)
    END             shift and go to state 57


state 16

    (16) statement -> MACRO . IDENTIFIER : IDENTIFIER ( ) {
    IDENTIFIER      shift and go to state 58


state 17

    (19) statement -> INCLUDE . STRING
    STRING          shift and go to state 59


state 18

    (34) expr -> STRING .
    ARROWOP         reduce using rule 34 (expr -> STRING .)
    <               reduce using rule 34 (expr -> STRING .)
    NOTEQ           reduce using rule 34 (expr -> STRING .)
    EQSTHAN         reduce using rule 34 (expr -> STRING .)
    EQGTHAN         reduce using rule 34 (expr -> STRING .)
    >               reduce using rule 34 (expr -> STRING .)
    EQEQ            reduce using rule 34 (expr -> STRING .)
    ARRAY           reduce using rule 34 (expr -> STRING .)
    /               reduce using rule 34 (expr -> STRING .)
    *               reduce using rule 34 (expr -> STRING .)
    -               reduce using rule 34 (expr -> STRING .)
    +               reduce using rule 34 (expr -> STRING .)
    $end            reduce using rule 34 (expr -> STRING .)
    )               reduce using rule 34 (expr -> STRING .)
    {               reduce using rule 34 (expr -> STRING .)


state 19

    (20) statement -> RETURN . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 60

state 20

    (21) statement -> FUNCTION . IDENTIFIER ( ) {
    IDENTIFIER      shift and go to state 61


state 21

    (23) expr -> PARAM . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 62

state 22

    (24) expr -> ARGV .
    ARROWOP         reduce using rule 24 (expr -> ARGV .)
    <               reduce using rule 24 (expr -> ARGV .)
    NOTEQ           reduce using rule 24 (expr -> ARGV .)
    EQSTHAN         reduce using rule 24 (expr -> ARGV .)
    EQGTHAN         reduce using rule 24 (expr -> ARGV .)
    >               reduce using rule 24 (expr -> ARGV .)
    EQEQ            reduce using rule 24 (expr -> ARGV .)
    ARRAY           reduce using rule 24 (expr -> ARGV .)
    /               reduce using rule 24 (expr -> ARGV .)
    *               reduce using rule 24 (expr -> ARGV .)
    -               reduce using rule 24 (expr -> ARGV .)
    +               reduce using rule 24 (expr -> ARGV .)
    $end            reduce using rule 24 (expr -> ARGV .)
    )               reduce using rule 24 (expr -> ARGV .)
    {               reduce using rule 24 (expr -> ARGV .)


state 23

    (25) expr -> ARGC .
    ARROWOP         reduce using rule 25 (expr -> ARGC .)
    <               reduce using rule 25 (expr -> ARGC .)
    NOTEQ           reduce using rule 25 (expr -> ARGC .)
    EQSTHAN         reduce using rule 25 (expr -> ARGC .)
    EQGTHAN         reduce using rule 25 (expr -> ARGC .)
    >               reduce using rule 25 (expr -> ARGC .)
    EQEQ            reduce using rule 25 (expr -> ARGC .)
    ARRAY           reduce using rule 25 (expr -> ARGC .)
    /               reduce using rule 25 (expr -> ARGC .)
    *               reduce using rule 25 (expr -> ARGC .)
    -               reduce using rule 25 (expr -> ARGC .)
    +               reduce using rule 25 (expr -> ARGC .)
    $end            reduce using rule 25 (expr -> ARGC .)
    )               reduce using rule 25 (expr -> ARGC .)
    {               reduce using rule 25 (expr -> ARGC .)


state 24

    (28) expr -> FLOAT .
    ARROWOP         reduce using rule 28 (expr -> FLOAT .)
    <               reduce using rule 28 (expr -> FLOAT .)
    NOTEQ           reduce using rule 28 (expr -> FLOAT .)
    EQSTHAN         reduce using rule 28 (expr -> FLOAT .)
    EQGTHAN         reduce using rule 28 (expr -> FLOAT .)
    >               reduce using rule 28 (expr -> FLOAT .)
    EQEQ            reduce using rule 28 (expr -> FLOAT .)
    ARRAY           reduce using rule 28 (expr -> FLOAT .)
    /               reduce using rule 28 (expr -> FLOAT .)
    *               reduce using rule 28 (expr -> FLOAT .)
    -               reduce using rule 28 (expr -> FLOAT .)
    +               reduce using rule 28 (expr -> FLOAT .)
    $end            reduce using rule 28 (expr -> FLOAT .)
    )               reduce using rule 28 (expr -> FLOAT .)
    {               reduce using rule 28 (expr -> FLOAT .)


state 25

    (32) expr -> - . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 63

state 26

    (33) expr -> NUMBER .
    ARROWOP         reduce using rule 33 (expr -> NUMBER .)
    <               reduce using rule 33 (expr -> NUMBER .)
    NOTEQ           reduce using rule 33 (expr -> NUMBER .)
    EQSTHAN         reduce using rule 33 (expr -> NUMBER .)
    EQGTHAN         reduce using rule 33 (expr -> NUMBER .)
    >               reduce using rule 33 (expr -> NUMBER .)
    EQEQ            reduce using rule 33 (expr -> NUMBER .)
    ARRAY           reduce using rule 33 (expr -> NUMBER .)
    /               reduce using rule 33 (expr -> NUMBER .)
    *               reduce using rule 33 (expr -> NUMBER .)
    -               reduce using rule 33 (expr -> NUMBER .)
    +               reduce using rule 33 (expr -> NUMBER .)
    $end            reduce using rule 33 (expr -> NUMBER .)
    )               reduce using rule 33 (expr -> NUMBER .)
    {               reduce using rule 33 (expr -> NUMBER .)


state 27

    (39) expr -> TYPEOF . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 64

state 28

    (3) statement -> FOR IDENTIFIER . IN expr {
    IN              shift and go to state 65


state 29

    (7) statement -> IDENTIFIER + . +
    +               shift and go to state 66


state 30

    (14) statement -> IDENTIFIER ARRAY . = expr
    =               shift and go to state 67


state 31

    (42) var_assign -> IDENTIFIER = . condition
    (43) var_assign -> IDENTIFIER = . expr
    (44) condition -> . expr < expr
    (45) condition -> . expr NOTEQ expr
    (46) condition -> . expr EQSTHAN expr
    (47) condition -> . expr EQGTHAN expr
    (48) condition -> . expr > expr
    (49) condition -> . expr EQEQ expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    condition                      shift and go to state 68
    expr                           shift and go to state 69

state 32

    (22) expr -> IDENTIFIER ( . )
    )               shift and go to state 70


state 33

    (9) statement -> expr ARROWOP . IDENTIFIER ( )
    IDENTIFIER      shift and go to state 71


state 34

    (44) condition -> expr < . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 72

state 35

    (45) condition -> expr NOTEQ . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 73

state 36

    (46) condition -> expr EQSTHAN . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 74

state 37

    (47) condition -> expr EQGTHAN . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 75

state 38

    (48) condition -> expr > . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 76

state 39

    (49) condition -> expr EQEQ . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 77

state 40

    (26) expr -> expr ARRAY .
    ARROWOP         reduce using rule 26 (expr -> expr ARRAY .)
    <               reduce using rule 26 (expr -> expr ARRAY .)
    NOTEQ           reduce using rule 26 (expr -> expr ARRAY .)
    EQSTHAN         reduce using rule 26 (expr -> expr ARRAY .)
    EQGTHAN         reduce using rule 26 (expr -> expr ARRAY .)
    >               reduce using rule 26 (expr -> expr ARRAY .)
    EQEQ            reduce using rule 26 (expr -> expr ARRAY .)
    ARRAY           reduce using rule 26 (expr -> expr ARRAY .)
    /               reduce using rule 26 (expr -> expr ARRAY .)
    *               reduce using rule 26 (expr -> expr ARRAY .)
    -               reduce using rule 26 (expr -> expr ARRAY .)
    +               reduce using rule 26 (expr -> expr ARRAY .)
    $end            reduce using rule 26 (expr -> expr ARRAY .)
    )               reduce using rule 26 (expr -> expr ARRAY .)
    {               reduce using rule 26 (expr -> expr ARRAY .)


state 41

    (35) expr -> expr / . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 78

state 42

    (36) expr -> expr * . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 79

state 43

    (37) expr -> expr - . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 80

state 44

    (38) expr -> expr + . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 81

state 45

    (4) statement -> WHILE ( . condition ) {
    (44) condition -> . expr < expr
    (45) condition -> . expr NOTEQ expr
    (46) condition -> . expr EQSTHAN expr
    (47) condition -> . expr EQGTHAN expr
    (48) condition -> . expr > expr
    (49) condition -> . expr EQEQ expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    condition                      shift and go to state 82
    expr                           shift and go to state 83

state 46

    (31) expr -> ( expr . )
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    )               shift and go to state 84
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 47

    (22) expr -> IDENTIFIER . ( )
    (30) expr -> IDENTIFIER .
    (               shift and go to state 32
    )               reduce using rule 30 (expr -> IDENTIFIER .)
    ARRAY           reduce using rule 30 (expr -> IDENTIFIER .)
    /               reduce using rule 30 (expr -> IDENTIFIER .)
    *               reduce using rule 30 (expr -> IDENTIFIER .)
    -               reduce using rule 30 (expr -> IDENTIFIER .)
    +               reduce using rule 30 (expr -> IDENTIFIER .)
    <               reduce using rule 30 (expr -> IDENTIFIER .)
    NOTEQ           reduce using rule 30 (expr -> IDENTIFIER .)
    EQSTHAN         reduce using rule 30 (expr -> IDENTIFIER .)
    EQGTHAN         reduce using rule 30 (expr -> IDENTIFIER .)
    >               reduce using rule 30 (expr -> IDENTIFIER .)
    EQEQ            reduce using rule 30 (expr -> IDENTIFIER .)
    $end            reduce using rule 30 (expr -> IDENTIFIER .)
    ARROWOP         reduce using rule 30 (expr -> IDENTIFIER .)
    {               reduce using rule 30 (expr -> IDENTIFIER .)


state 48

    (29) expr -> GLOBAL . IDENTIFIER
    IDENTIFIER      shift and go to state 85


state 49

    (5) statement -> ELSE { .
    $end            reduce using rule 5 (statement -> ELSE { .)


state 50

    (6) statement -> IF ( . condition ) {
    (44) condition -> . expr < expr
    (45) condition -> . expr NOTEQ expr
    (46) condition -> . expr EQSTHAN expr
    (47) condition -> . expr EQGTHAN expr
    (48) condition -> . expr > expr
    (49) condition -> . expr EQEQ expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    condition                      shift and go to state 86
    expr                           shift and go to state 83

state 51

    (8) statement -> ARROWOP GLOBAL . IDENTIFIER
    IDENTIFIER      shift and go to state 87


state 52

    (10) statement -> ARROWOP IDENTIFIER .
    $end            reduce using rule 10 (statement -> ARROWOP IDENTIFIER .)


state 53

    (17) statement -> GLOBAL MACRO . IDENTIFIER {
    IDENTIFIER      shift and go to state 88


state 54

    (40) var_assign -> GLOBAL IDENTIFIER . = condition
    (41) var_assign -> GLOBAL IDENTIFIER . = expr
    (29) expr -> GLOBAL IDENTIFIER .
    =               shift and go to state 89
    ARROWOP         reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    <               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    NOTEQ           reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    EQSTHAN         reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    EQGTHAN         reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    >               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    EQEQ            reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    ARRAY           reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    /               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    *               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    -               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    +               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    $end            reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)


state 55

    (11) statement -> WRITE condition .
    $end            reduce using rule 11 (statement -> WRITE condition .)


state 56

    (12) statement -> WRITE expr .
    (44) condition -> expr . < expr
    (45) condition -> expr . NOTEQ expr
    (46) condition -> expr . EQSTHAN expr
    (47) condition -> expr . EQGTHAN expr
    (48) condition -> expr . > expr
    (49) condition -> expr . EQEQ expr
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 12 (statement -> WRITE expr .)
    <               shift and go to state 34
    NOTEQ           shift and go to state 35
    EQSTHAN         shift and go to state 36
    EQGTHAN         shift and go to state 37
    >               shift and go to state 38
    EQEQ            shift and go to state 39
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 57

    (18) statement -> } END .
    $end            reduce using rule 18 (statement -> } END .)


state 58

    (16) statement -> MACRO IDENTIFIER . : IDENTIFIER ( ) {
    :               shift and go to state 90


state 59

    (19) statement -> INCLUDE STRING .
    $end            reduce using rule 19 (statement -> INCLUDE STRING .)


state 60

    (20) statement -> RETURN expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 20 (statement -> RETURN expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 61

    (21) statement -> FUNCTION IDENTIFIER . ( ) {
    (               shift and go to state 91


state 62

    (23) expr -> PARAM expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ARROWOP         reduce using rule 23 (expr -> PARAM expr .)
    <               reduce using rule 23 (expr -> PARAM expr .)
    NOTEQ           reduce using rule 23 (expr -> PARAM expr .)
    EQSTHAN         reduce using rule 23 (expr -> PARAM expr .)
    EQGTHAN         reduce using rule 23 (expr -> PARAM expr .)
    >               reduce using rule 23 (expr -> PARAM expr .)
    EQEQ            reduce using rule 23 (expr -> PARAM expr .)
    $end            reduce using rule 23 (expr -> PARAM expr .)
    )               reduce using rule 23 (expr -> PARAM expr .)
    {               reduce using rule 23 (expr -> PARAM expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 63

    (32) expr -> - expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    ARROWOP         reduce using rule 32 (expr -> - expr .)
    <               reduce using rule 32 (expr -> - expr .)
    NOTEQ           reduce using rule 32 (expr -> - expr .)
    EQSTHAN         reduce using rule 32 (expr -> - expr .)
    EQGTHAN         reduce using rule 32 (expr -> - expr .)
    >               reduce using rule 32 (expr -> - expr .)
    EQEQ            reduce using rule 32 (expr -> - expr .)
    ARRAY           reduce using rule 32 (expr -> - expr .)
    /               reduce using rule 32 (expr -> - expr .)
    *               reduce using rule 32 (expr -> - expr .)
    -               reduce using rule 32 (expr -> - expr .)
    +               reduce using rule 32 (expr -> - expr .)
    $end            reduce using rule 32 (expr -> - expr .)
    )               reduce using rule 32 (expr -> - expr .)
    {               reduce using rule 32 (expr -> - expr .)


state 64

    (39) expr -> TYPEOF expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ARROWOP         reduce using rule 39 (expr -> TYPEOF expr .)
    <               reduce using rule 39 (expr -> TYPEOF expr .)
    NOTEQ           reduce using rule 39 (expr -> TYPEOF expr .)
    EQSTHAN         reduce using rule 39 (expr -> TYPEOF expr .)
    EQGTHAN         reduce using rule 39 (expr -> TYPEOF expr .)
    >               reduce using rule 39 (expr -> TYPEOF expr .)
    EQEQ            reduce using rule 39 (expr -> TYPEOF expr .)
    $end            reduce using rule 39 (expr -> TYPEOF expr .)
    )               reduce using rule 39 (expr -> TYPEOF expr .)
    {               reduce using rule 39 (expr -> TYPEOF expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 65

    (3) statement -> FOR IDENTIFIER IN . expr {
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 92

state 66

    (7) statement -> IDENTIFIER + + .
    $end            reduce using rule 7 (statement -> IDENTIFIER + + .)


state 67

    (14) statement -> IDENTIFIER ARRAY = . expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    expr                           shift and go to state 93

state 68

    (42) var_assign -> IDENTIFIER = condition .
    $end            reduce using rule 42 (var_assign -> IDENTIFIER = condition .)


state 69

    (43) var_assign -> IDENTIFIER = expr .
    (44) condition -> expr . < expr
    (45) condition -> expr . NOTEQ expr
    (46) condition -> expr . EQSTHAN expr
    (47) condition -> expr . EQGTHAN expr
    (48) condition -> expr . > expr
    (49) condition -> expr . EQEQ expr
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 43 (var_assign -> IDENTIFIER = expr .)
    <               shift and go to state 34
    NOTEQ           shift and go to state 35
    EQSTHAN         shift and go to state 36
    EQGTHAN         shift and go to state 37
    >               shift and go to state 38
    EQEQ            shift and go to state 39
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 70

    (22) expr -> IDENTIFIER ( ) .
    ARROWOP         reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    <               reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    NOTEQ           reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    EQSTHAN         reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    EQGTHAN         reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    >               reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    EQEQ            reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    ARRAY           reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    /               reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    *               reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    -               reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    +               reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    $end            reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    )               reduce using rule 22 (expr -> IDENTIFIER ( ) .)
    {               reduce using rule 22 (expr -> IDENTIFIER ( ) .)


state 71

    (9) statement -> expr ARROWOP IDENTIFIER . ( )
    (               shift and go to state 94


state 72

    (44) condition -> expr < expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 44 (condition -> expr < expr .)
    )               reduce using rule 44 (condition -> expr < expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 73

    (45) condition -> expr NOTEQ expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 45 (condition -> expr NOTEQ expr .)
    )               reduce using rule 45 (condition -> expr NOTEQ expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 74

    (46) condition -> expr EQSTHAN expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 46 (condition -> expr EQSTHAN expr .)
    )               reduce using rule 46 (condition -> expr EQSTHAN expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 75

    (47) condition -> expr EQGTHAN expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 47 (condition -> expr EQGTHAN expr .)
    )               reduce using rule 47 (condition -> expr EQGTHAN expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 76

    (48) condition -> expr > expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 48 (condition -> expr > expr .)
    )               reduce using rule 48 (condition -> expr > expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 77

    (49) condition -> expr EQEQ expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 49 (condition -> expr EQEQ expr .)
    )               reduce using rule 49 (condition -> expr EQEQ expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 78

    (35) expr -> expr / expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    ARROWOP         reduce using rule 35 (expr -> expr / expr .)
    <               reduce using rule 35 (expr -> expr / expr .)
    NOTEQ           reduce using rule 35 (expr -> expr / expr .)
    EQSTHAN         reduce using rule 35 (expr -> expr / expr .)
    EQGTHAN         reduce using rule 35 (expr -> expr / expr .)
    >               reduce using rule 35 (expr -> expr / expr .)
    EQEQ            reduce using rule 35 (expr -> expr / expr .)
    ARRAY           reduce using rule 35 (expr -> expr / expr .)
    /               reduce using rule 35 (expr -> expr / expr .)
    *               reduce using rule 35 (expr -> expr / expr .)
    -               reduce using rule 35 (expr -> expr / expr .)
    +               reduce using rule 35 (expr -> expr / expr .)
    $end            reduce using rule 35 (expr -> expr / expr .)
    )               reduce using rule 35 (expr -> expr / expr .)
    {               reduce using rule 35 (expr -> expr / expr .)


state 79

    (36) expr -> expr * expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    ARROWOP         reduce using rule 36 (expr -> expr * expr .)
    <               reduce using rule 36 (expr -> expr * expr .)
    NOTEQ           reduce using rule 36 (expr -> expr * expr .)
    EQSTHAN         reduce using rule 36 (expr -> expr * expr .)
    EQGTHAN         reduce using rule 36 (expr -> expr * expr .)
    >               reduce using rule 36 (expr -> expr * expr .)
    EQEQ            reduce using rule 36 (expr -> expr * expr .)
    ARRAY           reduce using rule 36 (expr -> expr * expr .)
    /               reduce using rule 36 (expr -> expr * expr .)
    *               reduce using rule 36 (expr -> expr * expr .)
    -               reduce using rule 36 (expr -> expr * expr .)
    +               reduce using rule 36 (expr -> expr * expr .)
    $end            reduce using rule 36 (expr -> expr * expr .)
    )               reduce using rule 36 (expr -> expr * expr .)
    {               reduce using rule 36 (expr -> expr * expr .)


state 80

    (37) expr -> expr - expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    ARROWOP         reduce using rule 37 (expr -> expr - expr .)
    <               reduce using rule 37 (expr -> expr - expr .)
    NOTEQ           reduce using rule 37 (expr -> expr - expr .)
    EQSTHAN         reduce using rule 37 (expr -> expr - expr .)
    EQGTHAN         reduce using rule 37 (expr -> expr - expr .)
    >               reduce using rule 37 (expr -> expr - expr .)
    EQEQ            reduce using rule 37 (expr -> expr - expr .)
    ARRAY           reduce using rule 37 (expr -> expr - expr .)
    -               reduce using rule 37 (expr -> expr - expr .)
    +               reduce using rule 37 (expr -> expr - expr .)
    $end            reduce using rule 37 (expr -> expr - expr .)
    )               reduce using rule 37 (expr -> expr - expr .)
    {               reduce using rule 37 (expr -> expr - expr .)
    /               shift and go to state 41
    *               shift and go to state 42


state 81

    (38) expr -> expr + expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    ARROWOP         reduce using rule 38 (expr -> expr + expr .)
    <               reduce using rule 38 (expr -> expr + expr .)
    NOTEQ           reduce using rule 38 (expr -> expr + expr .)
    EQSTHAN         reduce using rule 38 (expr -> expr + expr .)
    EQGTHAN         reduce using rule 38 (expr -> expr + expr .)
    >               reduce using rule 38 (expr -> expr + expr .)
    EQEQ            reduce using rule 38 (expr -> expr + expr .)
    ARRAY           reduce using rule 38 (expr -> expr + expr .)
    -               reduce using rule 38 (expr -> expr + expr .)
    +               reduce using rule 38 (expr -> expr + expr .)
    $end            reduce using rule 38 (expr -> expr + expr .)
    )               reduce using rule 38 (expr -> expr + expr .)
    {               reduce using rule 38 (expr -> expr + expr .)
    /               shift and go to state 41
    *               shift and go to state 42


state 82

    (4) statement -> WHILE ( condition . ) {
    )               shift and go to state 95


state 83

    (44) condition -> expr . < expr
    (45) condition -> expr . NOTEQ expr
    (46) condition -> expr . EQSTHAN expr
    (47) condition -> expr . EQGTHAN expr
    (48) condition -> expr . > expr
    (49) condition -> expr . EQEQ expr
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    <               shift and go to state 34
    NOTEQ           shift and go to state 35
    EQSTHAN         shift and go to state 36
    EQGTHAN         shift and go to state 37
    >               shift and go to state 38
    EQEQ            shift and go to state 39
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 84

    (31) expr -> ( expr ) .
    ARROWOP         reduce using rule 31 (expr -> ( expr ) .)
    <               reduce using rule 31 (expr -> ( expr ) .)
    NOTEQ           reduce using rule 31 (expr -> ( expr ) .)
    EQSTHAN         reduce using rule 31 (expr -> ( expr ) .)
    EQGTHAN         reduce using rule 31 (expr -> ( expr ) .)
    >               reduce using rule 31 (expr -> ( expr ) .)
    EQEQ            reduce using rule 31 (expr -> ( expr ) .)
    ARRAY           reduce using rule 31 (expr -> ( expr ) .)
    /               reduce using rule 31 (expr -> ( expr ) .)
    *               reduce using rule 31 (expr -> ( expr ) .)
    -               reduce using rule 31 (expr -> ( expr ) .)
    +               reduce using rule 31 (expr -> ( expr ) .)
    $end            reduce using rule 31 (expr -> ( expr ) .)
    )               reduce using rule 31 (expr -> ( expr ) .)
    {               reduce using rule 31 (expr -> ( expr ) .)


state 85

    (29) expr -> GLOBAL IDENTIFIER .
    )               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    ARRAY           reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    /               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    *               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    -               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    +               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    <               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    NOTEQ           reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    EQSTHAN         reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    EQGTHAN         reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    >               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    EQEQ            reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    $end            reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    ARROWOP         reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)
    {               reduce using rule 29 (expr -> GLOBAL IDENTIFIER .)


state 86

    (6) statement -> IF ( condition . ) {
    )               shift and go to state 96


state 87

    (8) statement -> ARROWOP GLOBAL IDENTIFIER .
    $end            reduce using rule 8 (statement -> ARROWOP GLOBAL IDENTIFIER .)


state 88

    (17) statement -> GLOBAL MACRO IDENTIFIER . {
    {               shift and go to state 97


state 89

    (40) var_assign -> GLOBAL IDENTIFIER = . condition
    (41) var_assign -> GLOBAL IDENTIFIER = . expr
    (44) condition -> . expr < expr
    (45) condition -> . expr NOTEQ expr
    (46) condition -> . expr EQSTHAN expr
    (47) condition -> . expr EQGTHAN expr
    (48) condition -> . expr > expr
    (49) condition -> . expr EQEQ expr
    (22) expr -> . IDENTIFIER ( )
    (23) expr -> . PARAM expr
    (24) expr -> . ARGV
    (25) expr -> . ARGC
    (26) expr -> . expr ARRAY
    (27) expr -> . ARRAY
    (28) expr -> . FLOAT
    (29) expr -> . GLOBAL IDENTIFIER
    (30) expr -> . IDENTIFIER
    (31) expr -> . ( expr )
    (32) expr -> . - expr
    (33) expr -> . NUMBER
    (34) expr -> . STRING
    (35) expr -> . expr / expr
    (36) expr -> . expr * expr
    (37) expr -> . expr - expr
    (38) expr -> . expr + expr
    (39) expr -> . TYPEOF expr
    IDENTIFIER      shift and go to state 47
    PARAM           shift and go to state 21
    ARGV            shift and go to state 22
    ARGC            shift and go to state 23
    ARRAY           shift and go to state 14
    FLOAT           shift and go to state 24
    GLOBAL          shift and go to state 48
    (               shift and go to state 8
    -               shift and go to state 25
    NUMBER          shift and go to state 26
    STRING          shift and go to state 18
    TYPEOF          shift and go to state 27

    condition                      shift and go to state 98
    expr                           shift and go to state 99

state 90

    (16) statement -> MACRO IDENTIFIER : . IDENTIFIER ( ) {
    IDENTIFIER      shift and go to state 100


state 91

    (21) statement -> FUNCTION IDENTIFIER ( . ) {
    )               shift and go to state 101


state 92

    (3) statement -> FOR IDENTIFIER IN expr . {
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    {               shift and go to state 102
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 93

    (14) statement -> IDENTIFIER ARRAY = expr .
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 14 (statement -> IDENTIFIER ARRAY = expr .)
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 94

    (9) statement -> expr ARROWOP IDENTIFIER ( . )
    )               shift and go to state 103


state 95

    (4) statement -> WHILE ( condition ) . {
    {               shift and go to state 104


state 96

    (6) statement -> IF ( condition ) . {
    {               shift and go to state 105


state 97

    (17) statement -> GLOBAL MACRO IDENTIFIER { .
    $end            reduce using rule 17 (statement -> GLOBAL MACRO IDENTIFIER { .)


state 98

    (40) var_assign -> GLOBAL IDENTIFIER = condition .
    $end            reduce using rule 40 (var_assign -> GLOBAL IDENTIFIER = condition .)


state 99

    (41) var_assign -> GLOBAL IDENTIFIER = expr .
    (44) condition -> expr . < expr
    (45) condition -> expr . NOTEQ expr
    (46) condition -> expr . EQSTHAN expr
    (47) condition -> expr . EQGTHAN expr
    (48) condition -> expr . > expr
    (49) condition -> expr . EQEQ expr
    (26) expr -> expr . ARRAY
    (35) expr -> expr . / expr
    (36) expr -> expr . * expr
    (37) expr -> expr . - expr
    (38) expr -> expr . + expr
    $end            reduce using rule 41 (var_assign -> GLOBAL IDENTIFIER = expr .)
    <               shift and go to state 34
    NOTEQ           shift and go to state 35
    EQSTHAN         shift and go to state 36
    EQGTHAN         shift and go to state 37
    >               shift and go to state 38
    EQEQ            shift and go to state 39
    ARRAY           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 100

    (16) statement -> MACRO IDENTIFIER : IDENTIFIER . ( ) {
    (               shift and go to state 106


state 101

    (21) statement -> FUNCTION IDENTIFIER ( ) . {
    {               shift and go to state 107


state 102

    (3) statement -> FOR IDENTIFIER IN expr { .
    $end            reduce using rule 3 (statement -> FOR IDENTIFIER IN expr { .)


state 103

    (9) statement -> expr ARROWOP IDENTIFIER ( ) .
    $end            reduce using rule 9 (statement -> expr ARROWOP IDENTIFIER ( ) .)


state 104

    (4) statement -> WHILE ( condition ) { .
    $end            reduce using rule 4 (statement -> WHILE ( condition ) { .)


state 105

    (6) statement -> IF ( condition ) { .
    $end            reduce using rule 6 (statement -> IF ( condition ) { .)


state 106

    (16) statement -> MACRO IDENTIFIER : IDENTIFIER ( . ) {
    )               shift and go to state 108


state 107

    (21) statement -> FUNCTION IDENTIFIER ( ) { .
    $end            reduce using rule 21 (statement -> FUNCTION IDENTIFIER ( ) { .)


state 108

    (16) statement -> MACRO IDENTIFIER : IDENTIFIER ( ) . {
    {               shift and go to state 109


state 109

    (16) statement -> MACRO IDENTIFIER : IDENTIFIER ( ) { .
    $end            reduce using rule 16 (statement -> MACRO IDENTIFIER : IDENTIFIER ( ) { .)


Conflicts:

shift/reduce conflict for ARRAY in state 5 resolved as shift
shift/reduce conflict for + in state 5 resolved as shift
shift/reduce conflict for ARRAY in state 62 resolved as shift
shift/reduce conflict for / in state 62 resolved as shift
shift/reduce conflict for * in state 62 resolved as shift
shift/reduce conflict for - in state 62 resolved as shift
shift/reduce conflict for + in state 62 resolved as shift
shift/reduce conflict for ARRAY in state 64 resolved as shift
shift/reduce conflict for / in state 64 resolved as shift
shift/reduce conflict for * in state 64 resolved as shift
shift/reduce conflict for - in state 64 resolved as shift
shift/reduce conflict for + in state 64 resolved as shift